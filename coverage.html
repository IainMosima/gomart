
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>configs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/IainMosima/gomart/configs/config.go (0.0%)</option>
				
				<option value="file1">github.com/IainMosima/gomart/domains/category/repository/category_repo_mock.go (75.0%)</option>
				
				<option value="file2">github.com/IainMosima/gomart/domains/category/service/category_service_mock.go (100.0%)</option>
				
				<option value="file3">github.com/IainMosima/gomart/infrastructures/db/sqlc/category.sql.go (0.0%)</option>
				
				<option value="file4">github.com/IainMosima/gomart/infrastructures/db/sqlc/customer.sql.go (0.0%)</option>
				
				<option value="file5">github.com/IainMosima/gomart/infrastructures/db/sqlc/db.go (0.0%)</option>
				
				<option value="file6">github.com/IainMosima/gomart/infrastructures/db/sqlc/models.go (0.0%)</option>
				
				<option value="file7">github.com/IainMosima/gomart/infrastructures/db/sqlc/order.sql.go (0.0%)</option>
				
				<option value="file8">github.com/IainMosima/gomart/infrastructures/db/sqlc/order_item.sql.go (0.0%)</option>
				
				<option value="file9">github.com/IainMosima/gomart/infrastructures/db/sqlc/product.sql.go (0.0%)</option>
				
				<option value="file10">github.com/IainMosima/gomart/infrastructures/db/sqlc/store.go (0.0%)</option>
				
				<option value="file11">github.com/IainMosima/gomart/infrastructures/db/sqlc/store_mock.go (0.0%)</option>
				
				<option value="file12">github.com/IainMosima/gomart/infrastructures/repository/category_repo_impl.go (0.0%)</option>
				
				<option value="file13">github.com/IainMosima/gomart/main.go (0.0%)</option>
				
				<option value="file14">github.com/IainMosima/gomart/rest-server/handlers/category_handler_impl.go (100.0%)</option>
				
				<option value="file15">github.com/IainMosima/gomart/rest-server/routes/category_routes.go (0.0%)</option>
				
				<option value="file16">github.com/IainMosima/gomart/rest-server/server.go (0.0%)</option>
				
				<option value="file17">github.com/IainMosima/gomart/services/category/category_service_impl.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package configs

import (
        "log"

        "github.com/spf13/viper"
)

type Config struct {
        DBSource          string `mapstructure:"DB_SOURCE"`
        HTTPServerAddress string `mapstructure:"HTTP_SERVER_ADDRESS"`
}

func LoadConfig(path string) (config Config, err error) <span class="cov0" title="0">{
        viper.AddConfigPath(path)
        viper.SetConfigName("app")
        viper.SetConfigType("env")

        viper.AutomaticEnv()

        err = viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not read config file: %v", err)
                return
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Using local app.env configuration")
                err = viper.Unmarshal(&amp;config)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: category_repo_int.go

// Package repository is a generated GoMock package.
package repository

import (
        context "context"
        reflect "reflect"

        entity "github.com/IainMosima/gomart/domains/category/entity"
        gomock "go.uber.org/mock/gomock"
        uuid "github.com/google/uuid"
)

// MockCategoryRepository is a mock of CategoryRepository interface.
type MockCategoryRepository struct {
        ctrl     *gomock.Controller
        recorder *MockCategoryRepositoryMockRecorder
}

// MockCategoryRepositoryMockRecorder is the mock recorder for MockCategoryRepository.
type MockCategoryRepositoryMockRecorder struct {
        mock *MockCategoryRepository
}

// NewMockCategoryRepository creates a new mock instance.
func NewMockCategoryRepository(ctrl *gomock.Controller) *MockCategoryRepository <span class="cov8" title="1">{
        mock := &amp;MockCategoryRepository{ctrl: ctrl}
        mock.recorder = &amp;MockCategoryRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCategoryRepository) EXPECT() *MockCategoryRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockCategoryRepository) Create(ctx context.Context, category *entity.Category) (*entity.Category, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, category)
        ret0, _ := ret[0].(*entity.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockCategoryRepositoryMockRecorder) Create(ctx, category interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockCategoryRepository)(nil).Create), ctx, category)
}</span>

// GetAll mocks base method.
func (m *MockCategoryRepository) GetAll(ctx context.Context) ([]entity.Category, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", ctx)
        ret0, _ := ret[0].([]entity.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockCategoryRepositoryMockRecorder) GetAll(ctx interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockCategoryRepository)(nil).GetAll), ctx)
}</span>

// GetByID mocks base method.
func (m *MockCategoryRepository) GetByID(ctx context.Context, categoryID uuid.UUID) (*entity.Category, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", ctx, categoryID)
        ret0, _ := ret[0].(*entity.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockCategoryRepositoryMockRecorder) GetByID(ctx, categoryID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockCategoryRepository)(nil).GetByID), ctx, categoryID)
}</span>

// GetByParent mocks base method.
func (m *MockCategoryRepository) GetByParent(ctx context.Context, parentID *uuid.UUID) ([]entity.Category, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByParent", ctx, parentID)
        ret0, _ := ret[0].([]entity.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByParent indicates an expected call of GetByParent.
func (mr *MockCategoryRepositoryMockRecorder) GetByParent(ctx, parentID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByParent", reflect.TypeOf((*MockCategoryRepository)(nil).GetByParent), ctx, parentID)
}</span>

// GetRootCategories mocks base method.
func (m *MockCategoryRepository) GetRootCategories(ctx context.Context) ([]entity.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetRootCategories", ctx)
        ret0, _ := ret[0].([]entity.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetRootCategories indicates an expected call of GetRootCategories.
func (mr *MockCategoryRepositoryMockRecorder) GetRootCategories(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRootCategories", reflect.TypeOf((*MockCategoryRepository)(nil).GetRootCategories), ctx)
}</span>

// SoftDelete mocks base method.
func (m *MockCategoryRepository) SoftDelete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SoftDelete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SoftDelete indicates an expected call of SoftDelete.
func (mr *MockCategoryRepositoryMockRecorder) SoftDelete(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDelete", reflect.TypeOf((*MockCategoryRepository)(nil).SoftDelete), ctx, id)
}</span>

// Update mocks base method.
func (m *MockCategoryRepository) Update(ctx context.Context, category *entity.Category) (*entity.Category, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, category)
        ret0, _ := ret[0].(*entity.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockCategoryRepositoryMockRecorder) Update(ctx, category interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockCategoryRepository)(nil).Update), ctx, category)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: category_service_int.go

// Package service is a generated GoMock package.
package service

import (
        context "context"
        reflect "reflect"

        schema "github.com/IainMosima/gomart/domains/category/schema"
        gomock "go.uber.org/mock/gomock"
        uuid "github.com/google/uuid"
)

// MockCategoryService is a mock of CategoryService interface.
type MockCategoryService struct {
        ctrl     *gomock.Controller
        recorder *MockCategoryServiceMockRecorder
}

// MockCategoryServiceMockRecorder is the mock recorder for MockCategoryService.
type MockCategoryServiceMockRecorder struct {
        mock *MockCategoryService
}

// NewMockCategoryService creates a new mock instance.
func NewMockCategoryService(ctrl *gomock.Controller) *MockCategoryService <span class="cov8" title="1">{
        mock := &amp;MockCategoryService{ctrl: ctrl}
        mock.recorder = &amp;MockCategoryServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCategoryService) EXPECT() *MockCategoryServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateCategory mocks base method.
func (m *MockCategoryService) CreateCategory(ctx context.Context, req *schema.CreateCategoryRequest) (*schema.CategoryResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateCategory", ctx, req)
        ret0, _ := ret[0].(*schema.CategoryResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateCategory indicates an expected call of CreateCategory.
func (mr *MockCategoryServiceMockRecorder) CreateCategory(ctx, req interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCategory", reflect.TypeOf((*MockCategoryService)(nil).CreateCategory), ctx, req)
}</span>

// GetCategory mocks base method.
func (m *MockCategoryService) GetCategory(ctx context.Context, categoryID uuid.UUID) (*schema.CategoryResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategory", ctx, categoryID)
        ret0, _ := ret[0].(*schema.CategoryResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategory indicates an expected call of GetCategory.
func (mr *MockCategoryServiceMockRecorder) GetCategory(ctx, categoryID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategory", reflect.TypeOf((*MockCategoryService)(nil).GetCategory), ctx, categoryID)
}</span>

// GetCategoryChildren mocks base method.
func (m *MockCategoryService) GetCategoryChildren(ctx context.Context, parentID *uuid.UUID) (*schema.CategoryListResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategoryChildren", ctx, parentID)
        ret0, _ := ret[0].(*schema.CategoryListResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategoryChildren indicates an expected call of GetCategoryChildren.
func (mr *MockCategoryServiceMockRecorder) GetCategoryChildren(ctx, parentID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategoryChildren", reflect.TypeOf((*MockCategoryService)(nil).GetCategoryChildren), ctx, parentID)
}</span>

// ListCategories mocks base method.
func (m *MockCategoryService) ListCategories(ctx context.Context) (*schema.CategoryListResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListCategories", ctx)
        ret0, _ := ret[0].(*schema.CategoryListResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListCategories indicates an expected call of ListCategories.
func (mr *MockCategoryServiceMockRecorder) ListCategories(ctx interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCategories", reflect.TypeOf((*MockCategoryService)(nil).ListCategories), ctx)
}</span>

// UpdateCategory mocks base method.
func (m *MockCategoryService) UpdateCategory(ctx context.Context, categoryID uuid.UUID, req *schema.UpdateCategoryRequest) (*schema.CategoryResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateCategory", ctx, categoryID, req)
        ret0, _ := ret[0].(*schema.CategoryResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateCategory indicates an expected call of UpdateCategory.
func (mr *MockCategoryServiceMockRecorder) UpdateCategory(ctx, categoryID, req interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCategory", reflect.TypeOf((*MockCategoryService)(nil).UpdateCategory), ctx, categoryID, req)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: category.sql

package db

import (
        "context"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgtype"
)

const countCategories = `-- name: CountCategories :one
SELECT COUNT(*) FROM categories WHERE is_deleted = FALSE
`

func (q *Queries) CountCategories(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countCategories)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const countRootCategories = `-- name: CountRootCategories :one
SELECT COUNT(*) FROM categories WHERE parent_id IS NULL AND is_deleted = FALSE
`

func (q *Queries) CountRootCategories(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countRootCategories)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (category_name, parent_id)
VALUES ($1, $2)
RETURNING category_id, category_name, parent_id, created_at, updated_at, is_deleted
`

type CreateCategoryParams struct {
        CategoryName string      `json:"category_name"`
        ParentID     pgtype.UUID `json:"parent_id"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createCategory, arg.CategoryName, arg.ParentID)
        var i Category
        err := row.Scan(
                &amp;i.CategoryID,
                &amp;i.CategoryName,
                &amp;i.ParentID,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const createRootCategory = `-- name: CreateRootCategory :one
INSERT INTO categories (category_name)
VALUES ($1)
RETURNING category_id, category_name, parent_id, created_at, updated_at, is_deleted
`

func (q *Queries) CreateRootCategory(ctx context.Context, categoryName string) (Category, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createRootCategory, categoryName)
        var i Category
        err := row.Scan(
                &amp;i.CategoryID,
                &amp;i.CategoryName,
                &amp;i.ParentID,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getCategory = `-- name: GetCategory :one
SELECT category_id, category_name, parent_id, created_at, updated_at, is_deleted
FROM categories
WHERE category_id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetCategory(ctx context.Context, categoryID uuid.UUID) (Category, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getCategory, categoryID)
        var i Category
        err := row.Scan(
                &amp;i.CategoryID,
                &amp;i.CategoryName,
                &amp;i.ParentID,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getCategoryByName = `-- name: GetCategoryByName :one
SELECT category_id, category_name, parent_id, created_at, updated_at, is_deleted
FROM categories
WHERE category_name = $1 AND is_deleted = FALSE
`

func (q *Queries) GetCategoryByName(ctx context.Context, categoryName string) (Category, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getCategoryByName, categoryName)
        var i Category
        err := row.Scan(
                &amp;i.CategoryID,
                &amp;i.CategoryName,
                &amp;i.ParentID,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getCategoryChildren = `-- name: GetCategoryChildren :many
SELECT category_id, category_name, parent_id, created_at, updated_at, is_deleted
FROM categories
WHERE parent_id = $1 AND is_deleted = FALSE
ORDER BY category_name ASC
`

func (q *Queries) GetCategoryChildren(ctx context.Context, parentID pgtype.UUID) ([]Category, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getCategoryChildren, parentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Category{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Category
                if err := rows.Scan(
                        &amp;i.CategoryID,
                        &amp;i.CategoryName,
                        &amp;i.ParentID,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getCategoryDescendants = `-- name: GetCategoryDescendants :many
WITH RECURSIVE category_tree AS (
    SELECT c.category_id, c.category_name, c.parent_id, c.created_at, c.updated_at, c.is_deleted, 0 as level
    FROM categories c
    WHERE c.category_id = $1 AND c.is_deleted = FALSE
    
    UNION ALL
    
    SELECT c.category_id, c.category_name, c.parent_id, c.created_at, c.updated_at, c.is_deleted, ct.level + 1
    FROM categories c
    INNER JOIN category_tree ct ON c.parent_id = ct.category_id
    WHERE c.is_deleted = FALSE
)
SELECT category_id, category_name, parent_id, created_at, updated_at, is_deleted, level
FROM category_tree
ORDER BY level, category_name
`

type GetCategoryDescendantsRow struct {
        CategoryID   uuid.UUID          `json:"category_id"`
        CategoryName string             `json:"category_name"`
        ParentID     pgtype.UUID        `json:"parent_id"`
        CreatedAt    pgtype.Timestamptz `json:"created_at"`
        UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
        IsDeleted    pgtype.Bool        `json:"is_deleted"`
        Level        int32              `json:"level"`
}

func (q *Queries) GetCategoryDescendants(ctx context.Context, categoryID uuid.UUID) ([]GetCategoryDescendantsRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getCategoryDescendants, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []GetCategoryDescendantsRow{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetCategoryDescendantsRow
                if err := rows.Scan(
                        &amp;i.CategoryID,
                        &amp;i.CategoryName,
                        &amp;i.ParentID,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                        &amp;i.Level,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getCategoryPath = `-- name: GetCategoryPath :many
WITH RECURSIVE category_path AS (
    SELECT c.category_id, c.category_name, c.parent_id, c.created_at, c.updated_at, c.is_deleted, 0 as level
    FROM categories c
    WHERE c.category_id = $1 AND c.is_deleted = FALSE
    
    UNION ALL
    
    SELECT c.category_id, c.category_name, c.parent_id, c.created_at, c.updated_at, c.is_deleted, cp.level + 1
    FROM categories c
    INNER JOIN category_path cp ON cp.parent_id = c.category_id
    WHERE c.is_deleted = FALSE
)
SELECT category_id, category_name, parent_id, created_at, updated_at, is_deleted, level
FROM category_path
ORDER BY level DESC
`

type GetCategoryPathRow struct {
        CategoryID   uuid.UUID          `json:"category_id"`
        CategoryName string             `json:"category_name"`
        ParentID     pgtype.UUID        `json:"parent_id"`
        CreatedAt    pgtype.Timestamptz `json:"created_at"`
        UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
        IsDeleted    pgtype.Bool        `json:"is_deleted"`
        Level        int32              `json:"level"`
}

func (q *Queries) GetCategoryPath(ctx context.Context, categoryID uuid.UUID) ([]GetCategoryPathRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getCategoryPath, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []GetCategoryPathRow{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetCategoryPathRow
                if err := rows.Scan(
                        &amp;i.CategoryID,
                        &amp;i.CategoryName,
                        &amp;i.ParentID,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                        &amp;i.Level,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getRootCategories = `-- name: GetRootCategories :many
SELECT category_id, category_name, parent_id, created_at, updated_at, is_deleted
FROM categories
WHERE parent_id IS NULL AND is_deleted = FALSE
ORDER BY category_name ASC
`

func (q *Queries) GetRootCategories(ctx context.Context) ([]Category, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getRootCategories)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Category{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Category
                if err := rows.Scan(
                        &amp;i.CategoryID,
                        &amp;i.CategoryName,
                        &amp;i.ParentID,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listCategories = `-- name: ListCategories :many
SELECT category_id, category_name, parent_id, created_at, updated_at, is_deleted
FROM categories
WHERE is_deleted = FALSE
ORDER BY category_name ASC
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listCategories)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Category{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Category
                if err := rows.Scan(
                        &amp;i.CategoryID,
                        &amp;i.CategoryName,
                        &amp;i.ParentID,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const moveCategoryToParent = `-- name: MoveCategoryToParent :one
UPDATE categories
SET parent_id = $2, updated_at = NOW()
WHERE category_id = $1 AND is_deleted = FALSE
RETURNING category_id, category_name, parent_id, created_at, updated_at, is_deleted
`

type MoveCategoryToParentParams struct {
        CategoryID uuid.UUID   `json:"category_id"`
        ParentID   pgtype.UUID `json:"parent_id"`
}

func (q *Queries) MoveCategoryToParent(ctx context.Context, arg MoveCategoryToParentParams) (Category, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, moveCategoryToParent, arg.CategoryID, arg.ParentID)
        var i Category
        err := row.Scan(
                &amp;i.CategoryID,
                &amp;i.CategoryName,
                &amp;i.ParentID,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const softDeleteCategory = `-- name: SoftDeleteCategory :exec
UPDATE categories
SET is_deleted = TRUE, updated_at = NOW()
WHERE category_id = $1 AND is_deleted = FALSE
`

func (q *Queries) SoftDeleteCategory(ctx context.Context, categoryID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, softDeleteCategory, categoryID)
        return err
}</span>

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET category_name = $2, updated_at = NOW()
WHERE category_id = $1 AND is_deleted = FALSE
RETURNING category_id, category_name, parent_id, created_at, updated_at, is_deleted
`

type UpdateCategoryParams struct {
        CategoryID   uuid.UUID `json:"category_id"`
        CategoryName string    `json:"category_name"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateCategory, arg.CategoryID, arg.CategoryName)
        var i Category
        err := row.Scan(
                &amp;i.CategoryID,
                &amp;i.CategoryName,
                &amp;i.ParentID,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: customer.sql

package db

import (
        "context"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgtype"
)

const countCustomers = `-- name: CountCustomers :one
SELECT COUNT(*) FROM customers WHERE is_deleted = FALSE
`

func (q *Queries) CountCustomers(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countCustomers)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (email, first_name, last_name, phone, address, city, postal_code, openid_sub, setup_completed)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING customer_id, email, first_name, last_name, phone, address, city, postal_code, openid_sub, setup_completed, created_at, updated_at, is_deleted
`

type CreateCustomerParams struct {
        Email          string      `json:"email"`
        FirstName      string      `json:"first_name"`
        LastName       string      `json:"last_name"`
        Phone          pgtype.Text `json:"phone"`
        Address        pgtype.Text `json:"address"`
        City           pgtype.Text `json:"city"`
        PostalCode     pgtype.Text `json:"postal_code"`
        OpenidSub      string      `json:"openid_sub"`
        SetupCompleted pgtype.Bool `json:"setup_completed"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createCustomer,
                arg.Email,
                arg.FirstName,
                arg.LastName,
                arg.Phone,
                arg.Address,
                arg.City,
                arg.PostalCode,
                arg.OpenidSub,
                arg.SetupCompleted,
        )
        var i Customer
        err := row.Scan(
                &amp;i.CustomerID,
                &amp;i.Email,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Phone,
                &amp;i.Address,
                &amp;i.City,
                &amp;i.PostalCode,
                &amp;i.OpenidSub,
                &amp;i.SetupCompleted,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getCustomer = `-- name: GetCustomer :one
SELECT customer_id, email, first_name, last_name, phone, address, city, postal_code, openid_sub, setup_completed, created_at, updated_at, is_deleted
FROM customers
WHERE customer_id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetCustomer(ctx context.Context, customerID uuid.UUID) (Customer, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getCustomer, customerID)
        var i Customer
        err := row.Scan(
                &amp;i.CustomerID,
                &amp;i.Email,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Phone,
                &amp;i.Address,
                &amp;i.City,
                &amp;i.PostalCode,
                &amp;i.OpenidSub,
                &amp;i.SetupCompleted,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getCustomerByEmail = `-- name: GetCustomerByEmail :one
SELECT customer_id, email, first_name, last_name, phone, address, city, postal_code, openid_sub, setup_completed, created_at, updated_at, is_deleted
FROM customers
WHERE email = $1 AND is_deleted = FALSE
`

func (q *Queries) GetCustomerByEmail(ctx context.Context, email string) (Customer, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getCustomerByEmail, email)
        var i Customer
        err := row.Scan(
                &amp;i.CustomerID,
                &amp;i.Email,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Phone,
                &amp;i.Address,
                &amp;i.City,
                &amp;i.PostalCode,
                &amp;i.OpenidSub,
                &amp;i.SetupCompleted,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getCustomerByOpenIDSub = `-- name: GetCustomerByOpenIDSub :one
SELECT customer_id, email, first_name, last_name, phone, address, city, postal_code, openid_sub, setup_completed, created_at, updated_at, is_deleted
FROM customers
WHERE openid_sub = $1 AND is_deleted = FALSE
`

func (q *Queries) GetCustomerByOpenIDSub(ctx context.Context, openidSub string) (Customer, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getCustomerByOpenIDSub, openidSub)
        var i Customer
        err := row.Scan(
                &amp;i.CustomerID,
                &amp;i.Email,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Phone,
                &amp;i.Address,
                &amp;i.City,
                &amp;i.PostalCode,
                &amp;i.OpenidSub,
                &amp;i.SetupCompleted,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const listCustomers = `-- name: ListCustomers :many
SELECT customer_id, email, first_name, last_name, phone, address, city, postal_code, openid_sub, setup_completed, created_at, updated_at, is_deleted
FROM customers
WHERE is_deleted = FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListCustomers(ctx context.Context) ([]Customer, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listCustomers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Customer{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Customer
                if err := rows.Scan(
                        &amp;i.CustomerID,
                        &amp;i.Email,
                        &amp;i.FirstName,
                        &amp;i.LastName,
                        &amp;i.Phone,
                        &amp;i.Address,
                        &amp;i.City,
                        &amp;i.PostalCode,
                        &amp;i.OpenidSub,
                        &amp;i.SetupCompleted,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listCustomersBySetupStatus = `-- name: ListCustomersBySetupStatus :many
SELECT customer_id, email, first_name, last_name, phone, address, city, postal_code, openid_sub, setup_completed, created_at, updated_at, is_deleted
FROM customers
WHERE setup_completed = $1 AND is_deleted = FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListCustomersBySetupStatus(ctx context.Context, setupCompleted pgtype.Bool) ([]Customer, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listCustomersBySetupStatus, setupCompleted)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Customer{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Customer
                if err := rows.Scan(
                        &amp;i.CustomerID,
                        &amp;i.Email,
                        &amp;i.FirstName,
                        &amp;i.LastName,
                        &amp;i.Phone,
                        &amp;i.Address,
                        &amp;i.City,
                        &amp;i.PostalCode,
                        &amp;i.OpenidSub,
                        &amp;i.SetupCompleted,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const softDeleteCustomer = `-- name: SoftDeleteCustomer :exec
UPDATE customers
SET is_deleted = TRUE, updated_at = NOW()
WHERE customer_id = $1 AND is_deleted = FALSE
`

func (q *Queries) SoftDeleteCustomer(ctx context.Context, customerID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, softDeleteCustomer, customerID)
        return err
}</span>

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customers
SET email = $2, first_name = $3, last_name = $4, phone = $5, address = $6, city = $7, postal_code = $8, updated_at = NOW()
WHERE customer_id = $1 AND is_deleted = FALSE
RETURNING customer_id, email, first_name, last_name, phone, address, city, postal_code, openid_sub, setup_completed, created_at, updated_at, is_deleted
`

type UpdateCustomerParams struct {
        CustomerID uuid.UUID   `json:"customer_id"`
        Email      string      `json:"email"`
        FirstName  string      `json:"first_name"`
        LastName   string      `json:"last_name"`
        Phone      pgtype.Text `json:"phone"`
        Address    pgtype.Text `json:"address"`
        City       pgtype.Text `json:"city"`
        PostalCode pgtype.Text `json:"postal_code"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateCustomer,
                arg.CustomerID,
                arg.Email,
                arg.FirstName,
                arg.LastName,
                arg.Phone,
                arg.Address,
                arg.City,
                arg.PostalCode,
        )
        var i Customer
        err := row.Scan(
                &amp;i.CustomerID,
                &amp;i.Email,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Phone,
                &amp;i.Address,
                &amp;i.City,
                &amp;i.PostalCode,
                &amp;i.OpenidSub,
                &amp;i.SetupCompleted,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const updateCustomerSetupStatus = `-- name: UpdateCustomerSetupStatus :one
UPDATE customers
SET setup_completed = $2, updated_at = NOW()
WHERE customer_id = $1 AND is_deleted = FALSE
RETURNING customer_id, email, first_name, last_name, phone, address, city, postal_code, openid_sub, setup_completed, created_at, updated_at, is_deleted
`

type UpdateCustomerSetupStatusParams struct {
        CustomerID     uuid.UUID   `json:"customer_id"`
        SetupCompleted pgtype.Bool `json:"setup_completed"`
}

func (q *Queries) UpdateCustomerSetupStatus(ctx context.Context, arg UpdateCustomerSetupStatusParams) (Customer, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateCustomerSetupStatus, arg.CustomerID, arg.SetupCompleted)
        var i Customer
        err := row.Scan(
                &amp;i.CustomerID,
                &amp;i.Email,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Phone,
                &amp;i.Address,
                &amp;i.City,
                &amp;i.PostalCode,
                &amp;i.OpenidSub,
                &amp;i.SetupCompleted,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package db

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package db

import (
        "database/sql/driver"
        "fmt"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgtype"
)

type OrderStatus string

const (
        OrderStatusPending    OrderStatus = "pending"
        OrderStatusConfirmed  OrderStatus = "confirmed"
        OrderStatusProcessing OrderStatus = "processing"
        OrderStatusShipped    OrderStatus = "shipped"
        OrderStatusDelivered  OrderStatus = "delivered"
        OrderStatusCancelled  OrderStatus = "cancelled"
)

func (e *OrderStatus) Scan(src interface{}) error <span class="cov0" title="0">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = OrderStatus(s)</span>
        case string:<span class="cov0" title="0">
                *e = OrderStatus(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for OrderStatus: %T", src)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type NullOrderStatus struct {
        OrderStatus OrderStatus `json:"order_status"`
        Valid       bool        `json:"valid"` // Valid is true if OrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrderStatus) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.OrderStatus, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.OrderStatus.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullOrderStatus) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.OrderStatus), nil</span>
}

type Category struct {
        CategoryID   uuid.UUID          `json:"category_id"`
        CategoryName string             `json:"category_name"`
        ParentID     pgtype.UUID        `json:"parent_id"`
        CreatedAt    pgtype.Timestamptz `json:"created_at"`
        UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
        IsDeleted    pgtype.Bool        `json:"is_deleted"`
}

type Customer struct {
        CustomerID     uuid.UUID          `json:"customer_id"`
        Email          string             `json:"email"`
        FirstName      string             `json:"first_name"`
        LastName       string             `json:"last_name"`
        Phone          pgtype.Text        `json:"phone"`
        Address        pgtype.Text        `json:"address"`
        City           pgtype.Text        `json:"city"`
        PostalCode     pgtype.Text        `json:"postal_code"`
        OpenidSub      string             `json:"openid_sub"`
        SetupCompleted pgtype.Bool        `json:"setup_completed"`
        CreatedAt      pgtype.Timestamptz `json:"created_at"`
        UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
        IsDeleted      pgtype.Bool        `json:"is_deleted"`
}

type Order struct {
        OrderID         uuid.UUID          `json:"order_id"`
        CustomerID      uuid.UUID          `json:"customer_id"`
        OrderNumber     string             `json:"order_number"`
        Status          NullOrderStatus    `json:"status"`
        TotalAmount     pgtype.Numeric     `json:"total_amount"`
        ShippingAddress string             `json:"shipping_address"`
        BillingAddress  string             `json:"billing_address"`
        Notes           pgtype.Text        `json:"notes"`
        CreatedAt       pgtype.Timestamptz `json:"created_at"`
        UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
        IsDeleted       pgtype.Bool        `json:"is_deleted"`
}

type OrderItem struct {
        OrderItemID uuid.UUID          `json:"order_item_id"`
        OrderID     uuid.UUID          `json:"order_id"`
        ProductID   uuid.UUID          `json:"product_id"`
        Quantity    int32              `json:"quantity"`
        UnitPrice   pgtype.Numeric     `json:"unit_price"`
        TotalPrice  pgtype.Numeric     `json:"total_price"`
        CreatedAt   pgtype.Timestamptz `json:"created_at"`
        IsDeleted   pgtype.Bool        `json:"is_deleted"`
}

type Product struct {
        ProductID     uuid.UUID          `json:"product_id"`
        ProductName   string             `json:"product_name"`
        Description   pgtype.Text        `json:"description"`
        Price         pgtype.Numeric     `json:"price"`
        Sku           string             `json:"sku"`
        StockQuantity int32              `json:"stock_quantity"`
        CategoryID    uuid.UUID          `json:"category_id"`
        IsActive      pgtype.Bool        `json:"is_active"`
        CreatedAt     pgtype.Timestamptz `json:"created_at"`
        UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
        IsDeleted     pgtype.Bool        `json:"is_deleted"`
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: order.sql

package db

import (
        "context"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT COUNT(*) FROM orders WHERE is_deleted = FALSE
`

func (q *Queries) CountOrders(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countOrders)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const countOrdersByStatus = `-- name: CountOrdersByStatus :one
SELECT COUNT(*) FROM orders WHERE status = $1 AND is_deleted = FALSE
`

func (q *Queries) CountOrdersByStatus(ctx context.Context, status NullOrderStatus) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countOrdersByStatus, status)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (customer_id, order_number, status, total_amount, shipping_address, billing_address, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING order_id, customer_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at, is_deleted
`

type CreateOrderParams struct {
        CustomerID      uuid.UUID       `json:"customer_id"`
        OrderNumber     string          `json:"order_number"`
        Status          NullOrderStatus `json:"status"`
        TotalAmount     pgtype.Numeric  `json:"total_amount"`
        ShippingAddress string          `json:"shipping_address"`
        BillingAddress  string          `json:"billing_address"`
        Notes           pgtype.Text     `json:"notes"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createOrder,
                arg.CustomerID,
                arg.OrderNumber,
                arg.Status,
                arg.TotalAmount,
                arg.ShippingAddress,
                arg.BillingAddress,
                arg.Notes,
        )
        var i Order
        err := row.Scan(
                &amp;i.OrderID,
                &amp;i.CustomerID,
                &amp;i.OrderNumber,
                &amp;i.Status,
                &amp;i.TotalAmount,
                &amp;i.ShippingAddress,
                &amp;i.BillingAddress,
                &amp;i.Notes,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getOrder = `-- name: GetOrder :one
SELECT order_id, customer_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at, is_deleted
FROM orders
WHERE order_id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetOrder(ctx context.Context, orderID uuid.UUID) (Order, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getOrder, orderID)
        var i Order
        err := row.Scan(
                &amp;i.OrderID,
                &amp;i.CustomerID,
                &amp;i.OrderNumber,
                &amp;i.Status,
                &amp;i.TotalAmount,
                &amp;i.ShippingAddress,
                &amp;i.BillingAddress,
                &amp;i.Notes,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getOrderByNumber = `-- name: GetOrderByNumber :one
SELECT order_id, customer_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at, is_deleted
FROM orders
WHERE order_number = $1 AND is_deleted = FALSE
`

func (q *Queries) GetOrderByNumber(ctx context.Context, orderNumber string) (Order, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getOrderByNumber, orderNumber)
        var i Order
        err := row.Scan(
                &amp;i.OrderID,
                &amp;i.CustomerID,
                &amp;i.OrderNumber,
                &amp;i.Status,
                &amp;i.TotalAmount,
                &amp;i.ShippingAddress,
                &amp;i.BillingAddress,
                &amp;i.Notes,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const listOrders = `-- name: ListOrders :many
SELECT order_id, customer_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at, is_deleted
FROM orders
WHERE is_deleted = FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListOrders(ctx context.Context) ([]Order, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOrders)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Order{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Order
                if err := rows.Scan(
                        &amp;i.OrderID,
                        &amp;i.CustomerID,
                        &amp;i.OrderNumber,
                        &amp;i.Status,
                        &amp;i.TotalAmount,
                        &amp;i.ShippingAddress,
                        &amp;i.BillingAddress,
                        &amp;i.Notes,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listOrdersByCustomer = `-- name: ListOrdersByCustomer :many
SELECT order_id, customer_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at, is_deleted
FROM orders
WHERE customer_id = $1 AND is_deleted = FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListOrdersByCustomer(ctx context.Context, customerID uuid.UUID) ([]Order, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOrdersByCustomer, customerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Order{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Order
                if err := rows.Scan(
                        &amp;i.OrderID,
                        &amp;i.CustomerID,
                        &amp;i.OrderNumber,
                        &amp;i.Status,
                        &amp;i.TotalAmount,
                        &amp;i.ShippingAddress,
                        &amp;i.BillingAddress,
                        &amp;i.Notes,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listOrdersByDateRange = `-- name: ListOrdersByDateRange :many
SELECT order_id, customer_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at, is_deleted
FROM orders
WHERE created_at &gt;= $1 AND created_at &lt;= $2 AND is_deleted = FALSE
ORDER BY created_at DESC
`

type ListOrdersByDateRangeParams struct {
        CreatedAt   pgtype.Timestamptz `json:"created_at"`
        CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

func (q *Queries) ListOrdersByDateRange(ctx context.Context, arg ListOrdersByDateRangeParams) ([]Order, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOrdersByDateRange, arg.CreatedAt, arg.CreatedAt_2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Order{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Order
                if err := rows.Scan(
                        &amp;i.OrderID,
                        &amp;i.CustomerID,
                        &amp;i.OrderNumber,
                        &amp;i.Status,
                        &amp;i.TotalAmount,
                        &amp;i.ShippingAddress,
                        &amp;i.BillingAddress,
                        &amp;i.Notes,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listOrdersByStatus = `-- name: ListOrdersByStatus :many
SELECT order_id, customer_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at, is_deleted
FROM orders
WHERE status = $1 AND is_deleted = FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListOrdersByStatus(ctx context.Context, status NullOrderStatus) ([]Order, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOrdersByStatus, status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Order{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Order
                if err := rows.Scan(
                        &amp;i.OrderID,
                        &amp;i.CustomerID,
                        &amp;i.OrderNumber,
                        &amp;i.Status,
                        &amp;i.TotalAmount,
                        &amp;i.ShippingAddress,
                        &amp;i.BillingAddress,
                        &amp;i.Notes,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const softDeleteOrder = `-- name: SoftDeleteOrder :exec
UPDATE orders
SET is_deleted = TRUE, updated_at = NOW()
WHERE order_id = $1 AND is_deleted = FALSE
`

func (q *Queries) SoftDeleteOrder(ctx context.Context, orderID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, softDeleteOrder, orderID)
        return err
}</span>

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET status = $2, total_amount = $3, shipping_address = $4, billing_address = $5, notes = $6, updated_at = NOW()
WHERE order_id = $1 AND is_deleted = FALSE
RETURNING order_id, customer_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at, is_deleted
`

type UpdateOrderParams struct {
        OrderID         uuid.UUID       `json:"order_id"`
        Status          NullOrderStatus `json:"status"`
        TotalAmount     pgtype.Numeric  `json:"total_amount"`
        ShippingAddress string          `json:"shipping_address"`
        BillingAddress  string          `json:"billing_address"`
        Notes           pgtype.Text     `json:"notes"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateOrder,
                arg.OrderID,
                arg.Status,
                arg.TotalAmount,
                arg.ShippingAddress,
                arg.BillingAddress,
                arg.Notes,
        )
        var i Order
        err := row.Scan(
                &amp;i.OrderID,
                &amp;i.CustomerID,
                &amp;i.OrderNumber,
                &amp;i.Status,
                &amp;i.TotalAmount,
                &amp;i.ShippingAddress,
                &amp;i.BillingAddress,
                &amp;i.Notes,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET status = $2, updated_at = NOW()
WHERE order_id = $1 AND is_deleted = FALSE
RETURNING order_id, customer_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at, is_deleted
`

type UpdateOrderStatusParams struct {
        OrderID uuid.UUID       `json:"order_id"`
        Status  NullOrderStatus `json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateOrderStatus, arg.OrderID, arg.Status)
        var i Order
        err := row.Scan(
                &amp;i.OrderID,
                &amp;i.CustomerID,
                &amp;i.OrderNumber,
                &amp;i.Status,
                &amp;i.TotalAmount,
                &amp;i.ShippingAddress,
                &amp;i.BillingAddress,
                &amp;i.Notes,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const updateOrderTotal = `-- name: UpdateOrderTotal :one
UPDATE orders
SET total_amount = $2, updated_at = NOW()
WHERE order_id = $1 AND is_deleted = FALSE
RETURNING order_id, customer_id, order_number, status, total_amount, shipping_address, billing_address, notes, created_at, updated_at, is_deleted
`

type UpdateOrderTotalParams struct {
        OrderID     uuid.UUID      `json:"order_id"`
        TotalAmount pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) UpdateOrderTotal(ctx context.Context, arg UpdateOrderTotalParams) (Order, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateOrderTotal, arg.OrderID, arg.TotalAmount)
        var i Order
        err := row.Scan(
                &amp;i.OrderID,
                &amp;i.CustomerID,
                &amp;i.OrderNumber,
                &amp;i.Status,
                &amp;i.TotalAmount,
                &amp;i.ShippingAddress,
                &amp;i.BillingAddress,
                &amp;i.Notes,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: order_item.sql

package db

import (
        "context"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgtype"
)

const countOrderItems = `-- name: CountOrderItems :one
SELECT COUNT(*) FROM order_items WHERE is_deleted = FALSE
`

func (q *Queries) CountOrderItems(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countOrderItems)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const countOrderItemsByOrder = `-- name: CountOrderItemsByOrder :one
SELECT COUNT(*) FROM order_items WHERE order_id = $1 AND is_deleted = FALSE
`

func (q *Queries) CountOrderItemsByOrder(ctx context.Context, orderID uuid.UUID) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countOrderItemsByOrder, orderID)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, product_id, quantity, unit_price, total_price)
VALUES ($1, $2, $3, $4, $5)
RETURNING order_item_id, order_id, product_id, quantity, unit_price, total_price, created_at, is_deleted
`

type CreateOrderItemParams struct {
        OrderID    uuid.UUID      `json:"order_id"`
        ProductID  uuid.UUID      `json:"product_id"`
        Quantity   int32          `json:"quantity"`
        UnitPrice  pgtype.Numeric `json:"unit_price"`
        TotalPrice pgtype.Numeric `json:"total_price"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createOrderItem,
                arg.OrderID,
                arg.ProductID,
                arg.Quantity,
                arg.UnitPrice,
                arg.TotalPrice,
        )
        var i OrderItem
        err := row.Scan(
                &amp;i.OrderItemID,
                &amp;i.OrderID,
                &amp;i.ProductID,
                &amp;i.Quantity,
                &amp;i.UnitPrice,
                &amp;i.TotalPrice,
                &amp;i.CreatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getOrderItem = `-- name: GetOrderItem :one
SELECT order_item_id, order_id, product_id, quantity, unit_price, total_price, created_at, is_deleted
FROM order_items
WHERE order_item_id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetOrderItem(ctx context.Context, orderItemID uuid.UUID) (OrderItem, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getOrderItem, orderItemID)
        var i OrderItem
        err := row.Scan(
                &amp;i.OrderItemID,
                &amp;i.OrderID,
                &amp;i.ProductID,
                &amp;i.Quantity,
                &amp;i.UnitPrice,
                &amp;i.TotalPrice,
                &amp;i.CreatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getOrderItemsWithDetails = `-- name: GetOrderItemsWithDetails :many
SELECT oi.order_item_id, oi.order_id, oi.product_id, oi.quantity, oi.unit_price, oi.total_price, oi.created_at, oi.is_deleted,
       p.product_name, p.sku, p.description
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id
WHERE oi.order_id = $1 AND oi.is_deleted = FALSE AND p.is_deleted = FALSE
ORDER BY oi.created_at ASC
`

type GetOrderItemsWithDetailsRow struct {
        OrderItemID uuid.UUID          `json:"order_item_id"`
        OrderID     uuid.UUID          `json:"order_id"`
        ProductID   uuid.UUID          `json:"product_id"`
        Quantity    int32              `json:"quantity"`
        UnitPrice   pgtype.Numeric     `json:"unit_price"`
        TotalPrice  pgtype.Numeric     `json:"total_price"`
        CreatedAt   pgtype.Timestamptz `json:"created_at"`
        IsDeleted   pgtype.Bool        `json:"is_deleted"`
        ProductName string             `json:"product_name"`
        Sku         string             `json:"sku"`
        Description pgtype.Text        `json:"description"`
}

func (q *Queries) GetOrderItemsWithDetails(ctx context.Context, orderID uuid.UUID) ([]GetOrderItemsWithDetailsRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getOrderItemsWithDetails, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []GetOrderItemsWithDetailsRow{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetOrderItemsWithDetailsRow
                if err := rows.Scan(
                        &amp;i.OrderItemID,
                        &amp;i.OrderID,
                        &amp;i.ProductID,
                        &amp;i.Quantity,
                        &amp;i.UnitPrice,
                        &amp;i.TotalPrice,
                        &amp;i.CreatedAt,
                        &amp;i.IsDeleted,
                        &amp;i.ProductName,
                        &amp;i.Sku,
                        &amp;i.Description,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getOrderTotalFromItems = `-- name: GetOrderTotalFromItems :one
SELECT COALESCE(SUM(total_price), 0) as order_total
FROM order_items
WHERE order_id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetOrderTotalFromItems(ctx context.Context, orderID uuid.UUID) (interface{}, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getOrderTotalFromItems, orderID)
        var order_total interface{}
        err := row.Scan(&amp;order_total)
        return order_total, err
}</span>

const listOrderItems = `-- name: ListOrderItems :many
SELECT order_item_id, order_id, product_id, quantity, unit_price, total_price, created_at, is_deleted
FROM order_items
WHERE is_deleted = FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListOrderItems(ctx context.Context) ([]OrderItem, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOrderItems)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []OrderItem{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i OrderItem
                if err := rows.Scan(
                        &amp;i.OrderItemID,
                        &amp;i.OrderID,
                        &amp;i.ProductID,
                        &amp;i.Quantity,
                        &amp;i.UnitPrice,
                        &amp;i.TotalPrice,
                        &amp;i.CreatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listOrderItemsByOrder = `-- name: ListOrderItemsByOrder :many
SELECT order_item_id, order_id, product_id, quantity, unit_price, total_price, created_at, is_deleted
FROM order_items
WHERE order_id = $1 AND is_deleted = FALSE
ORDER BY created_at ASC
`

func (q *Queries) ListOrderItemsByOrder(ctx context.Context, orderID uuid.UUID) ([]OrderItem, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOrderItemsByOrder, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []OrderItem{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i OrderItem
                if err := rows.Scan(
                        &amp;i.OrderItemID,
                        &amp;i.OrderID,
                        &amp;i.ProductID,
                        &amp;i.Quantity,
                        &amp;i.UnitPrice,
                        &amp;i.TotalPrice,
                        &amp;i.CreatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listOrderItemsByProduct = `-- name: ListOrderItemsByProduct :many
SELECT order_item_id, order_id, product_id, quantity, unit_price, total_price, created_at, is_deleted
FROM order_items
WHERE product_id = $1 AND is_deleted = FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListOrderItemsByProduct(ctx context.Context, productID uuid.UUID) ([]OrderItem, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOrderItemsByProduct, productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []OrderItem{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i OrderItem
                if err := rows.Scan(
                        &amp;i.OrderItemID,
                        &amp;i.OrderID,
                        &amp;i.ProductID,
                        &amp;i.Quantity,
                        &amp;i.UnitPrice,
                        &amp;i.TotalPrice,
                        &amp;i.CreatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const softDeleteOrderItem = `-- name: SoftDeleteOrderItem :exec
UPDATE order_items
SET is_deleted = TRUE
WHERE order_item_id = $1 AND is_deleted = FALSE
`

func (q *Queries) SoftDeleteOrderItem(ctx context.Context, orderItemID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, softDeleteOrderItem, orderItemID)
        return err
}</span>

const softDeleteOrderItemsByOrder = `-- name: SoftDeleteOrderItemsByOrder :exec
UPDATE order_items
SET is_deleted = TRUE
WHERE order_id = $1 AND is_deleted = FALSE
`

func (q *Queries) SoftDeleteOrderItemsByOrder(ctx context.Context, orderID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, softDeleteOrderItemsByOrder, orderID)
        return err
}</span>

const updateOrderItem = `-- name: UpdateOrderItem :one
UPDATE order_items
SET quantity = $2, unit_price = $3, total_price = $4
WHERE order_item_id = $1 AND is_deleted = FALSE
RETURNING order_item_id, order_id, product_id, quantity, unit_price, total_price, created_at, is_deleted
`

type UpdateOrderItemParams struct {
        OrderItemID uuid.UUID      `json:"order_item_id"`
        Quantity    int32          `json:"quantity"`
        UnitPrice   pgtype.Numeric `json:"unit_price"`
        TotalPrice  pgtype.Numeric `json:"total_price"`
}

func (q *Queries) UpdateOrderItem(ctx context.Context, arg UpdateOrderItemParams) (OrderItem, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateOrderItem,
                arg.OrderItemID,
                arg.Quantity,
                arg.UnitPrice,
                arg.TotalPrice,
        )
        var i OrderItem
        err := row.Scan(
                &amp;i.OrderItemID,
                &amp;i.OrderID,
                &amp;i.ProductID,
                &amp;i.Quantity,
                &amp;i.UnitPrice,
                &amp;i.TotalPrice,
                &amp;i.CreatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const updateOrderItemQuantity = `-- name: UpdateOrderItemQuantity :one
UPDATE order_items
SET quantity = $2, total_price = quantity * unit_price
WHERE order_item_id = $1 AND is_deleted = FALSE
RETURNING order_item_id, order_id, product_id, quantity, unit_price, total_price, created_at, is_deleted
`

type UpdateOrderItemQuantityParams struct {
        OrderItemID uuid.UUID `json:"order_item_id"`
        Quantity    int32     `json:"quantity"`
}

func (q *Queries) UpdateOrderItemQuantity(ctx context.Context, arg UpdateOrderItemQuantityParams) (OrderItem, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateOrderItemQuantity, arg.OrderItemID, arg.Quantity)
        var i OrderItem
        err := row.Scan(
                &amp;i.OrderItemID,
                &amp;i.OrderID,
                &amp;i.ProductID,
                &amp;i.Quantity,
                &amp;i.UnitPrice,
                &amp;i.TotalPrice,
                &amp;i.CreatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product.sql

package db

import (
        "context"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgtype"
)

const countActiveProducts = `-- name: CountActiveProducts :one
SELECT COUNT(*) FROM products WHERE is_active = true AND is_deleted = FALSE
`

func (q *Queries) CountActiveProducts(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countActiveProducts)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products WHERE is_deleted = FALSE
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, countProducts)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (product_name, description, price, sku, stock_quantity, category_id, is_active)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING product_id, product_name, description, price, sku, stock_quantity, category_id, is_active, created_at, updated_at, is_deleted
`

type CreateProductParams struct {
        ProductName   string         `json:"product_name"`
        Description   pgtype.Text    `json:"description"`
        Price         pgtype.Numeric `json:"price"`
        Sku           string         `json:"sku"`
        StockQuantity int32          `json:"stock_quantity"`
        CategoryID    uuid.UUID      `json:"category_id"`
        IsActive      pgtype.Bool    `json:"is_active"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createProduct,
                arg.ProductName,
                arg.Description,
                arg.Price,
                arg.Sku,
                arg.StockQuantity,
                arg.CategoryID,
                arg.IsActive,
        )
        var i Product
        err := row.Scan(
                &amp;i.ProductID,
                &amp;i.ProductName,
                &amp;i.Description,
                &amp;i.Price,
                &amp;i.Sku,
                &amp;i.StockQuantity,
                &amp;i.CategoryID,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getProduct = `-- name: GetProduct :one
SELECT product_id, product_name, description, price, sku, stock_quantity, category_id, is_active, created_at, updated_at, is_deleted
FROM products
WHERE product_id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetProduct(ctx context.Context, productID uuid.UUID) (Product, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getProduct, productID)
        var i Product
        err := row.Scan(
                &amp;i.ProductID,
                &amp;i.ProductName,
                &amp;i.Description,
                &amp;i.Price,
                &amp;i.Sku,
                &amp;i.StockQuantity,
                &amp;i.CategoryID,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const getProductBySKU = `-- name: GetProductBySKU :one
SELECT product_id, product_name, description, price, sku, stock_quantity, category_id, is_active, created_at, updated_at, is_deleted
FROM products
WHERE sku = $1 AND is_deleted = FALSE
`

func (q *Queries) GetProductBySKU(ctx context.Context, sku string) (Product, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getProductBySKU, sku)
        var i Product
        err := row.Scan(
                &amp;i.ProductID,
                &amp;i.ProductName,
                &amp;i.Description,
                &amp;i.Price,
                &amp;i.Sku,
                &amp;i.StockQuantity,
                &amp;i.CategoryID,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const listActiveProducts = `-- name: ListActiveProducts :many
SELECT product_id, product_name, description, price, sku, stock_quantity, category_id, is_active, created_at, updated_at, is_deleted
FROM products
WHERE is_active = true AND is_deleted = FALSE
ORDER BY product_name ASC
`

func (q *Queries) ListActiveProducts(ctx context.Context) ([]Product, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listActiveProducts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Product{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Product
                if err := rows.Scan(
                        &amp;i.ProductID,
                        &amp;i.ProductName,
                        &amp;i.Description,
                        &amp;i.Price,
                        &amp;i.Sku,
                        &amp;i.StockQuantity,
                        &amp;i.CategoryID,
                        &amp;i.IsActive,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listProducts = `-- name: ListProducts :many
SELECT product_id, product_name, description, price, sku, stock_quantity, category_id, is_active, created_at, updated_at, is_deleted
FROM products
WHERE is_deleted = FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListProducts(ctx context.Context) ([]Product, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listProducts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Product{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Product
                if err := rows.Scan(
                        &amp;i.ProductID,
                        &amp;i.ProductName,
                        &amp;i.Description,
                        &amp;i.Price,
                        &amp;i.Sku,
                        &amp;i.StockQuantity,
                        &amp;i.CategoryID,
                        &amp;i.IsActive,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT product_id, product_name, description, price, sku, stock_quantity, category_id, is_active, created_at, updated_at, is_deleted
FROM products
WHERE category_id = $1 AND is_deleted = FALSE
ORDER BY product_name ASC
`

func (q *Queries) ListProductsByCategory(ctx context.Context, categoryID uuid.UUID) ([]Product, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listProductsByCategory, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Product{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Product
                if err := rows.Scan(
                        &amp;i.ProductID,
                        &amp;i.ProductName,
                        &amp;i.Description,
                        &amp;i.Price,
                        &amp;i.Sku,
                        &amp;i.StockQuantity,
                        &amp;i.CategoryID,
                        &amp;i.IsActive,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listProductsInStock = `-- name: ListProductsInStock :many
SELECT product_id, product_name, description, price, sku, stock_quantity, category_id, is_active, created_at, updated_at, is_deleted
FROM products
WHERE stock_quantity &gt; 0 AND is_deleted = FALSE
ORDER BY product_name ASC
`

func (q *Queries) ListProductsInStock(ctx context.Context) ([]Product, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listProductsInStock)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Product{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Product
                if err := rows.Scan(
                        &amp;i.ProductID,
                        &amp;i.ProductName,
                        &amp;i.Description,
                        &amp;i.Price,
                        &amp;i.Sku,
                        &amp;i.StockQuantity,
                        &amp;i.CategoryID,
                        &amp;i.IsActive,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.IsDeleted,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const softDeleteProduct = `-- name: SoftDeleteProduct :exec
UPDATE products
SET is_deleted = TRUE, updated_at = NOW()
WHERE product_id = $1 AND is_deleted = FALSE
`

func (q *Queries) SoftDeleteProduct(ctx context.Context, productID uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, softDeleteProduct, productID)
        return err
}</span>

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET product_name = $2, description = $3, price = $4, stock_quantity = $5, category_id = $6, is_active = $7, updated_at = NOW()
WHERE product_id = $1 AND is_deleted = FALSE
RETURNING product_id, product_name, description, price, sku, stock_quantity, category_id, is_active, created_at, updated_at, is_deleted
`

type UpdateProductParams struct {
        ProductID     uuid.UUID      `json:"product_id"`
        ProductName   string         `json:"product_name"`
        Description   pgtype.Text    `json:"description"`
        Price         pgtype.Numeric `json:"price"`
        StockQuantity int32          `json:"stock_quantity"`
        CategoryID    uuid.UUID      `json:"category_id"`
        IsActive      pgtype.Bool    `json:"is_active"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateProduct,
                arg.ProductID,
                arg.ProductName,
                arg.Description,
                arg.Price,
                arg.StockQuantity,
                arg.CategoryID,
                arg.IsActive,
        )
        var i Product
        err := row.Scan(
                &amp;i.ProductID,
                &amp;i.ProductName,
                &amp;i.Description,
                &amp;i.Price,
                &amp;i.Sku,
                &amp;i.StockQuantity,
                &amp;i.CategoryID,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const updateProductStatus = `-- name: UpdateProductStatus :one
UPDATE products
SET is_active = $2, updated_at = NOW()
WHERE product_id = $1 AND is_deleted = FALSE
RETURNING product_id, product_name, description, price, sku, stock_quantity, category_id, is_active, created_at, updated_at, is_deleted
`

type UpdateProductStatusParams struct {
        ProductID uuid.UUID   `json:"product_id"`
        IsActive  pgtype.Bool `json:"is_active"`
}

func (q *Queries) UpdateProductStatus(ctx context.Context, arg UpdateProductStatusParams) (Product, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateProductStatus, arg.ProductID, arg.IsActive)
        var i Product
        err := row.Scan(
                &amp;i.ProductID,
                &amp;i.ProductName,
                &amp;i.Description,
                &amp;i.Price,
                &amp;i.Sku,
                &amp;i.StockQuantity,
                &amp;i.CategoryID,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>

const updateProductStock = `-- name: UpdateProductStock :one
UPDATE products
SET stock_quantity = $2, updated_at = NOW()
WHERE product_id = $1 AND is_deleted = FALSE
RETURNING product_id, product_name, description, price, sku, stock_quantity, category_id, is_active, created_at, updated_at, is_deleted
`

type UpdateProductStockParams struct {
        ProductID     uuid.UUID `json:"product_id"`
        StockQuantity int32     `json:"stock_quantity"`
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) (Product, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateProductStock, arg.ProductID, arg.StockQuantity)
        var i Product
        err := row.Scan(
                &amp;i.ProductID,
                &amp;i.ProductName,
                &amp;i.Description,
                &amp;i.Price,
                &amp;i.Sku,
                &amp;i.StockQuantity,
                &amp;i.CategoryID,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.IsDeleted,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">//go:generate mockgen -source=store.go -destination=store_mock.go -package=db

package db

import (
        "github.com/jackc/pgx/v5/pgxpool"
)

type Store interface {
        Querier
}

type SQLStore struct {
        connPool *pgxpool.Pool
        *Queries
}

func NewStore(connPool *pgxpool.Pool) Store <span class="cov0" title="0">{
        return &amp;SQLStore{
                connPool: connPool,
                Queries:  New(connPool),
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: store.go

// Package db is a generated GoMock package.
package db

import (
        context "context"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
        uuid "github.com/google/uuid"
        pgtype "github.com/jackc/pgx/v5/pgtype"
)

// MockStore is a mock of Store interface.
type MockStore struct {
        ctrl     *gomock.Controller
        recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
        mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore <span class="cov0" title="0">{
        mock := &amp;MockStore{ctrl: ctrl}
        mock.recorder = &amp;MockStoreMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateCategory mocks base method.
func (m *MockStore) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateCategory", ctx, arg)
        ret0, _ := ret[0].(Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateCategory indicates an expected call of CreateCategory.
func (mr *MockStoreMockRecorder) CreateCategory(ctx, arg interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCategory", reflect.TypeOf((*MockStore)(nil).CreateCategory), ctx, arg)
}</span>

// GetCategory mocks base method.
func (m *MockStore) GetCategory(ctx context.Context, categoryID uuid.UUID) (Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategory", ctx, categoryID)
        ret0, _ := ret[0].(Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategory indicates an expected call of GetCategory.
func (mr *MockStoreMockRecorder) GetCategory(ctx, categoryID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategory", reflect.TypeOf((*MockStore)(nil).GetCategory), ctx, categoryID)
}</span>

// GetCategoryChildren mocks base method.
func (m *MockStore) GetCategoryChildren(ctx context.Context, parentID pgtype.UUID) ([]Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategoryChildren", ctx, parentID)
        ret0, _ := ret[0].([]Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategoryChildren indicates an expected call of GetCategoryChildren.
func (mr *MockStoreMockRecorder) GetCategoryChildren(ctx, parentID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategoryChildren", reflect.TypeOf((*MockStore)(nil).GetCategoryChildren), ctx, parentID)
}</span>

// GetRootCategories mocks base method.
func (m *MockStore) GetRootCategories(ctx context.Context) ([]Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetRootCategories", ctx)
        ret0, _ := ret[0].([]Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetRootCategories indicates an expected call of GetRootCategories.
func (mr *MockStoreMockRecorder) GetRootCategories(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRootCategories", reflect.TypeOf((*MockStore)(nil).GetRootCategories), ctx)
}</span>

// ListCategories mocks base method.
func (m *MockStore) ListCategories(ctx context.Context) ([]Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListCategories", ctx)
        ret0, _ := ret[0].([]Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListCategories indicates an expected call of ListCategories.
func (mr *MockStoreMockRecorder) ListCategories(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCategories", reflect.TypeOf((*MockStore)(nil).ListCategories), ctx)
}</span>

// UpdateCategory mocks base method.
func (m *MockStore) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateCategory", ctx, arg)
        ret0, _ := ret[0].(Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateCategory indicates an expected call of UpdateCategory.
func (mr *MockStoreMockRecorder) UpdateCategory(ctx, arg interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCategory", reflect.TypeOf((*MockStore)(nil).UpdateCategory), ctx, arg)
}</span>

// SoftDeleteCategory mocks base method.
func (m *MockStore) SoftDeleteCategory(ctx context.Context, categoryID uuid.UUID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SoftDeleteCategory", ctx, categoryID)
        ret0, _ := ret[1].(error)
        return ret0
}</span>

// SoftDeleteCategory indicates an expected call of SoftDeleteCategory.
func (mr *MockStoreMockRecorder) SoftDeleteCategory(ctx, categoryID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDeleteCategory", reflect.TypeOf((*MockStore)(nil).SoftDeleteCategory), ctx, categoryID)
}</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "context"

        "github.com/IainMosima/gomart/domains/category/entity"
        domainRepo "github.com/IainMosima/gomart/domains/category/repository"
        db "github.com/IainMosima/gomart/infrastructures/db/sqlc"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgtype"
)

type CategoryRepositoryImpl struct {
        store db.Store
}

func NewCategoryRepository(store db.Store) domainRepo.CategoryRepository <span class="cov0" title="0">{
        return &amp;CategoryRepositoryImpl{
                store: store,
        }
}</span>

func (r *CategoryRepositoryImpl) Create(ctx context.Context, category *entity.Category) (*entity.Category, error) <span class="cov0" title="0">{
        var parentID pgtype.UUID
        if category.ParentID != nil </span><span class="cov0" title="0">{
                parentID = pgtype.UUID{
                        Bytes: *category.ParentID,
                        Valid: true,
                }
        }</span>

        <span class="cov0" title="0">params := db.CreateCategoryParams{
                CategoryName: category.CategoryName,
                ParentID:     parentID,
        }

        result, err := r.store.CreateCategory(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return r.convertToEntity(result), nil</span>
}

func (r *CategoryRepositoryImpl) GetByID(ctx context.Context, categoryID uuid.UUID) (*entity.Category, error) <span class="cov0" title="0">{
        result, err := r.store.GetCategory(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return r.convertToEntity(result), nil</span>
}

func (r *CategoryRepositoryImpl) GetByParent(ctx context.Context, parentID *uuid.UUID) ([]entity.Category, error) <span class="cov0" title="0">{
        var pgParentID pgtype.UUID
        if parentID != nil </span><span class="cov0" title="0">{
                pgParentID = pgtype.UUID{
                        Bytes: *parentID,
                        Valid: true,
                }
        }</span>

        <span class="cov0" title="0">results, err := r.store.GetCategoryChildren(ctx, pgParentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">categories := make([]entity.Category, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                categories[i] = *r.convertToEntity(result)
        }</span>

        <span class="cov0" title="0">return categories, nil</span>
}

func (r *CategoryRepositoryImpl) GetRootCategories(ctx context.Context) ([]entity.Category, error) <span class="cov0" title="0">{
        results, err := r.store.GetRootCategories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">categories := make([]entity.Category, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                categories[i] = *r.convertToEntity(result)
        }</span>

        <span class="cov0" title="0">return categories, nil</span>
}

func (r *CategoryRepositoryImpl) GetAll(ctx context.Context) ([]entity.Category, error) <span class="cov0" title="0">{
        results, err := r.store.ListCategories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">categories := make([]entity.Category, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                categories[i] = *r.convertToEntity(result)
        }</span>

        <span class="cov0" title="0">return categories, nil</span>
}

func (r *CategoryRepositoryImpl) Update(ctx context.Context, category *entity.Category) (*entity.Category, error) <span class="cov0" title="0">{
        params := db.UpdateCategoryParams{
                CategoryID:   category.CategoryID,
                CategoryName: category.CategoryName,
        }

        result, err := r.store.UpdateCategory(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return r.convertToEntity(result), nil</span>
}

func (r *CategoryRepositoryImpl) SoftDelete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.store.SoftDeleteCategory(ctx, id)
}</span>

func (r *CategoryRepositoryImpl) convertToEntity(dbCategory db.Category) *entity.Category <span class="cov0" title="0">{
        category := &amp;entity.Category{
                CategoryID:   dbCategory.CategoryID,
                CategoryName: dbCategory.CategoryName,
                CreatedAt:    dbCategory.CreatedAt.Time,
                IsDeleted:    dbCategory.IsDeleted.Bool,
        }

        if dbCategory.ParentID.Valid </span><span class="cov0" title="0">{
                parentUUID := uuid.UUID(dbCategory.ParentID.Bytes)
                category.ParentID = &amp;parentUUID
        }</span>

        <span class="cov0" title="0">if dbCategory.UpdatedAt.Valid </span><span class="cov0" title="0">{
                updatedAt := dbCategory.UpdatedAt.Time
                category.UpdatedAt = &amp;updatedAt
        }</span>

        <span class="cov0" title="0">return category</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

import (
        "context"
        "log"

        "github.com/IainMosima/gomart/configs"
        db "github.com/IainMosima/gomart/infrastructures/db/sqlc"
        categoryRepo "github.com/IainMosima/gomart/infrastructures/repository"
        "github.com/IainMosima/gomart/rest-server"
        "github.com/IainMosima/gomart/rest-server/handlers"
        categoryService "github.com/IainMosima/gomart/services/category"
        "github.com/jackc/pgx/v5/pgxpool"
)

func main() <span class="cov0" title="0">{
        config, err := configs.LoadConfig("configs")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("cannot load config:", err)
        }</span>

        <span class="cov0" title="0">connPool, err := pgxpool.New(context.Background(), config.DBSource)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("cannot connect to db:", err)
        }</span>
        <span class="cov0" title="0">defer connPool.Close()

        store := db.NewStore(connPool)

        // Initialize repositories
        categoryRepository := categoryRepo.NewCategoryRepository(store)

        // Initialize services
        categoryServiceImpl := categoryService.NewCategoryService(categoryRepository)

        // Initialize handlers
        categoryHandler := handlers.NewCategoryHandler(categoryServiceImpl)

        // Initialize REST server
        server := rest_server.NewRestServer(categoryHandler)

        // Start HTTP server
        if err := server.Start(config.HTTPServerAddress); err != nil </span><span class="cov0" title="0">{
                log.Fatal("cannot start HTTP server:", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "net/http"

        "github.com/IainMosima/gomart/domains/category/schema"
        "github.com/IainMosima/gomart/domains/category/service"
        "github.com/IainMosima/gomart/rest-server/dtos"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type CategoryHandlerImpl struct {
        categoryService service.CategoryService
}

func NewCategoryHandler(categoryService service.CategoryService) CategoryHandlerInterface <span class="cov8" title="1">{
        return &amp;CategoryHandlerImpl{
                categoryService: categoryService,
        }
}</span>

func (h *CategoryHandlerImpl) CreateCategory(c *gin.Context) <span class="cov8" title="1">{
        var req dtos.CreateCategoryRequestDTO
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">schemaReq := &amp;schema.CreateCategoryRequest{
                CategoryName: req.CategoryName,
                ParentID:     req.ParentID,
        }

        result, err := h.categoryService.CreateCategory(c.Request.Context(), schemaReq)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := &amp;dtos.CategoryResponseDTO{
                CategoryID:   result.CategoryID,
                CategoryName: result.CategoryName,
                ParentID:     result.ParentID,
                CreatedAt:    result.CreatedAt,
                UpdatedAt:    result.UpdatedAt,
        }

        c.JSON(http.StatusCreated, response)</span>
}

func (h *CategoryHandlerImpl) GetCategory(c *gin.Context) <span class="cov8" title="1">{
        categoryIDStr := c.Param("id")
        categoryID, err := uuid.Parse(categoryIDStr)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid category ID"})
                return
        }</span>

        <span class="cov8" title="1">result, err := h.categoryService.GetCategory(c.Request.Context(), categoryID)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := &amp;dtos.CategoryResponseDTO{
                CategoryID:   result.CategoryID,
                CategoryName: result.CategoryName,
                ParentID:     result.ParentID,
                CreatedAt:    result.CreatedAt,
                UpdatedAt:    result.UpdatedAt,
        }

        c.JSON(http.StatusOK, response)</span>
}

func (h *CategoryHandlerImpl) UpdateCategory(c *gin.Context) <span class="cov8" title="1">{
        categoryIDStr := c.Param("id")
        categoryID, err := uuid.Parse(categoryIDStr)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid category ID"})
                return
        }</span>

        <span class="cov8" title="1">var req dtos.UpdateCategoryRequestDTO
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">schemaReq := &amp;schema.UpdateCategoryRequest{
                CategoryName: req.CategoryName,
        }

        result, err := h.categoryService.UpdateCategory(c.Request.Context(), categoryID, schemaReq)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := &amp;dtos.CategoryResponseDTO{
                CategoryID:   result.CategoryID,
                CategoryName: result.CategoryName,
                ParentID:     result.ParentID,
                CreatedAt:    result.CreatedAt,
                UpdatedAt:    result.UpdatedAt,
        }

        c.JSON(http.StatusOK, response)</span>
}

func (h *CategoryHandlerImpl) ListCategories(c *gin.Context) <span class="cov8" title="1">{
        result, err := h.categoryService.ListCategories(c.Request.Context())
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">categories := make([]*dtos.CategoryResponseDTO, len(result.Categories))
        for i, cat := range result.Categories </span><span class="cov8" title="1">{
                categories[i] = &amp;dtos.CategoryResponseDTO{
                        CategoryID:   cat.CategoryID,
                        CategoryName: cat.CategoryName,
                        ParentID:     cat.ParentID,
                        CreatedAt:    cat.CreatedAt,
                        UpdatedAt:    cat.UpdatedAt,
                }
        }</span>

        <span class="cov8" title="1">response := &amp;dtos.CategoryListResponseDTO{
                Categories: categories,
                Total:      result.Total,
        }

        c.JSON(http.StatusOK, response)</span>
}

func (h *CategoryHandlerImpl) GetCategoryChildren(c *gin.Context) <span class="cov8" title="1">{
        categoryIDStr := c.Param("id")

        var parentID *uuid.UUID
        if categoryIDStr != "" </span><span class="cov8" title="1">{
                id, err := uuid.Parse(categoryIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid category ID"})
                        return
                }</span>
                <span class="cov8" title="1">parentID = &amp;id</span>
        }

        <span class="cov8" title="1">result, err := h.categoryService.GetCategoryChildren(c.Request.Context(), parentID)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">categories := make([]*dtos.CategoryResponseDTO, len(result.Categories))
        for i, cat := range result.Categories </span><span class="cov8" title="1">{
                categories[i] = &amp;dtos.CategoryResponseDTO{
                        CategoryID:   cat.CategoryID,
                        CategoryName: cat.CategoryName,
                        ParentID:     cat.ParentID,
                        CreatedAt:    cat.CreatedAt,
                        UpdatedAt:    cat.UpdatedAt,
                }
        }</span>

        <span class="cov8" title="1">response := &amp;dtos.CategoryListResponseDTO{
                Categories: categories,
                Total:      result.Total,
        }

        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package routes

import (
        "github.com/IainMosima/gomart/rest-server/handlers"
        "github.com/gin-gonic/gin"
)

func SetupCategoryRoutes(router *gin.Engine, categoryHandler handlers.CategoryHandlerInterface) <span class="cov0" title="0">{
        categories := router.Group("/categories")
        </span><span class="cov0" title="0">{
                categories.POST("", categoryHandler.CreateCategory)
                categories.GET("", categoryHandler.ListCategories)
                categories.GET("/:id", categoryHandler.GetCategory)
                categories.PUT("/:id", categoryHandler.UpdateCategory)
                categories.GET("/:id/children", categoryHandler.GetCategoryChildren)
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package rest_server

import (
        "github.com/IainMosima/gomart/rest-server/handlers"
        "github.com/IainMosima/gomart/rest-server/routes"
        "github.com/gin-gonic/gin"
)

type RestServer struct {
        router          *gin.Engine
        categoryHandler handlers.CategoryHandlerInterface
}

func NewRestServer(categoryHandler handlers.CategoryHandlerInterface) *RestServer <span class="cov0" title="0">{
        router := gin.New()

        _ = router.SetTrustedProxies(nil)

        router.Use(gin.Logger())
        router.Use(gin.Recovery())

        server := &amp;RestServer{
                router:          router,
                categoryHandler: categoryHandler,
        }

        server.setupRoutes()
        return server
}</span>

func (s *RestServer) setupRoutes() <span class="cov0" title="0">{
        routes.SetupCategoryRoutes(s.router, s.categoryHandler)
}</span>

func (s *RestServer) Start(addr string) error <span class="cov0" title="0">{
        return s.router.Run(addr)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package category

import (
        "context"

        "github.com/IainMosima/gomart/domains/category/entity"
        "github.com/IainMosima/gomart/domains/category/repository"
        "github.com/IainMosima/gomart/domains/category/schema"
        "github.com/IainMosima/gomart/domains/category/service"
        "github.com/google/uuid"
)

type CategoryServiceImpl struct {
        categoryRepo repository.CategoryRepository
}

func NewCategoryService(categoryRepo repository.CategoryRepository) service.CategoryService <span class="cov8" title="1">{
        return &amp;CategoryServiceImpl{
                categoryRepo: categoryRepo,
        }
}</span>

func (s *CategoryServiceImpl) CreateCategory(ctx context.Context, req *schema.CreateCategoryRequest) (*schema.CategoryResponse, error) <span class="cov8" title="1">{
        category := &amp;entity.Category{
                CategoryID:   uuid.New(),
                CategoryName: req.CategoryName,
                ParentID:     req.ParentID,
        }

        createdCategory, err := s.categoryRepo.Create(ctx, category)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return s.entityToResponse(createdCategory), nil</span>
}

func (s *CategoryServiceImpl) GetCategory(ctx context.Context, categoryID uuid.UUID) (*schema.CategoryResponse, error) <span class="cov8" title="1">{
        category, err := s.categoryRepo.GetByID(ctx, categoryID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return s.entityToResponse(category), nil</span>
}

func (s *CategoryServiceImpl) UpdateCategory(ctx context.Context, categoryID uuid.UUID, req *schema.UpdateCategoryRequest) (*schema.CategoryResponse, error) <span class="cov8" title="1">{
        existingCategory, err := s.categoryRepo.GetByID(ctx, categoryID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">existingCategory.CategoryName = req.CategoryName

        updatedCategory, err := s.categoryRepo.Update(ctx, existingCategory)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return s.entityToResponse(updatedCategory), nil</span>
}

func (s *CategoryServiceImpl) ListCategories(ctx context.Context) (*schema.CategoryListResponse, error) <span class="cov8" title="1">{
        categories, err := s.categoryRepo.GetAll(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">responses := make([]*schema.CategoryResponse, len(categories))
        for i, category := range categories </span><span class="cov8" title="1">{
                responses[i] = s.entityToResponse(&amp;category)
        }</span>

        <span class="cov8" title="1">return &amp;schema.CategoryListResponse{
                Categories: responses,
                Total:      int64(len(responses)),
        }, nil</span>
}

func (s *CategoryServiceImpl) GetCategoryChildren(ctx context.Context, parentID *uuid.UUID) (*schema.CategoryListResponse, error) <span class="cov8" title="1">{
        categories, err := s.categoryRepo.GetByParent(ctx, parentID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">responses := make([]*schema.CategoryResponse, len(categories))
        for i, category := range categories </span><span class="cov8" title="1">{
                responses[i] = s.entityToResponse(&amp;category)
        }</span>

        <span class="cov8" title="1">return &amp;schema.CategoryListResponse{
                Categories: responses,
                Total:      int64(len(responses)),
        }, nil</span>
}

func (s *CategoryServiceImpl) entityToResponse(category *entity.Category) *schema.CategoryResponse <span class="cov8" title="1">{
        return &amp;schema.CategoryResponse{
                CategoryID:   category.CategoryID,
                CategoryName: category.CategoryName,
                ParentID:     category.ParentID,
                CreatedAt:    category.CreatedAt,
                UpdatedAt:    category.UpdatedAt,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
